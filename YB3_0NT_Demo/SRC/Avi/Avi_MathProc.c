#include "stdafx.h"
#include "Avi_MathProc.h"

unsigned short Tabsin[181] =
{
	//0:0.5:90 度； 乘以32768；2的15次方，运算时左移15位； Tabsin[ ]>>15;
	3,           286,         572,         858,         1144,        1429,        1715,        2000,        2286,
	2571,        2856,        3141,        3425,        3709,        3993,        4277,        4560,        4843,
	5126,        5408,        5690,        5971,        6252,        6533,        6813,        7092,        7371,
	7650,        7927,        8204,        8481,        8757,        9032,        9307,        9580,        9854,
	10126,       10397,       10668,       10938,       11207,       11476,       11743,       12010,       12275,
	12540,       12803,       13066,       13328,       13589,       13848,       14107,       14365,       14621,
	14876,       15131,       15384,       15636,       15886,       16136,       16384,       16631,       16877,
	17121,       17364,       17606,       17847,       18086,       18324,       18560,       18795,       19028,
	19261,       19491,       19720,       19948,       20174,       20399,       20622,       20843,       21063,
	21281,       21498,       21713,       21926,       22138,       22348,       22556,       22763,       22967,
	23170,       23372,       23571,       23769,       23965,       24159,       24351,       24542,       24730,
	24917,       25102,       25285,       25466,       25645,       25822,       25997,       26170,       26341,
	26510,       26677,       26842,       27005,       27166,       27325,       27482,       27636,       27789,
	27939,       28088,       28234,       28378,       28520,       28660,       28797,       28932,       29066,
	29197,       29325,       29452,       29576,       29698,       29818,       29935,       30050,       30163,
	30274,       30382,       30488,       30592,       30693,       30792,       30888,       30983,       31075,
	31164,       31251,       31336,       31419,       31499,       31576,       31651,       31724,       31795,
	31863,       31928,       31991,       32052,       32110,       32166,       32219,       32270,       32319,
	32365,       32408,       32449,       32488,       32524,       32557,       32588,       32617,       32643,
	32667,       32688,       32707,       32723,       32737,       32748,       32757,       32763,       32767,
	32768
};

unsigned short Tabcos[181] =
{
	32768,       32767,       32763,       32757,       32748,       32737,       32723,       32707,       32688,
	32667,       32643,       32617,       32588,       32557,       32524,       32488,       32449,       32408,
	32365,       32319,       32270,       32219,       32166,       32110,       32052,       31991,       31928,
	31863,       31795,       31724,       31651,       31576,       31499,       31419,       31336,       31251,
	31164,       31075,       30983,       30888,       30792,       30693,       30592,       30488,       30382,
	30274,       30163,       30050,       29935,       29818,       29698,       29576,       29452,       29325,
	29197,       29066,       28932,       28797,       28660,       28520,       28378,       28234,       28088,
	27939,       27789,       27636,       27482,       27325,       27166,       27005,       26842,       26677,
	26510,       26341,       26170,       25997,       25822,       25645,       25466,       25285,       25102,
	24917,       24730,       24542,       24351,       24159,       23965,       23769,       23571,       23372,
	23170,       22967,       22763,       22556,       22348,       22138,       21926,       21713,       21498,
	21281,       21063,       20843,       20622,       20399,       20174,       19948,       19720,       19491,
	19261,       19028,       18795,       18560,       18324,       18086,       17847,       17606,       17364,
	17121,       16877,       16631,       16384,       16136,       15886,       15636,       15384,       15131,
	14876,       14621,       14365,       14107,       13848,       13589,       13328,       13066,       12803,
	12540,       12275,       12010,       11743,       11476,       11207,       10938,       10668,       10397,
	10126,       9854,        9580,        9307,        9032,        8757,        8481,        8204,        7927,
	7650,        7371,        7092,        6813,        6533,        6252,        5971,        5690,        5408,
	5126,        4843,        4560,        4277,        3993,        3709,        3425,        3141,        2856,
	2571,        2286,        2000,        1715,        1429,        1144,        858,         572,         286,
	3
};


//unsigned short Tabtan[181] = 
//{
//	//0:0.5:90 度； 乘以256；2的8次方，运算时左移8位； TabTan[ ]>>8;
//	0,			2,			4,			6,			8,			11,			13,			15,			17,
//	20,			22,			24,			26,			29,			31,			33,			35,			38,
//	40,			42,			45,			47,			49,			52,			54,			56,			59,
//	61,			63,			66,			68,			70,			73,			75,			78,			80,
//	83,			85,			88,			90,			93,			95,			98,			100,		103,
//	106,		108,		111,		113,		116,		119,		122,		124,		127,
//	130,		133,		136,		138,		141,		144,		147,		150,		153,
//	156,		159,		163,		166,		169,		172,		175,		179,		182,
//	185,		189,		192,		196,		200,		203,		207,		211,		214,
//	218,		222,		226,		230,		234,		238,		242,		247,		251,
//	256,		260,		265,		269,		274,		279,		284,		289,		294,
//	299,		305,		310,		316,		321,		327,		333,		339,		345,
//	352,		358,		365,		372,		379,		386,		394,		401,		409,
//	417,		426,		434,		443,		452,		461,		471,		481,		491,
//	502,		513,		524,		536,		548,		561,		574,		588,		603,
//	618,		633,		649,		666,		684,		703,		722,		743,		765,
//	787,		811,		837,		864,		892,		923,		955,		989,		1026,
//	1066,		1108,		1154,		1204,		1258,		1317,		1381,		1451,		1529,
//	1616,		1712,		1821,		1944,		2084,		2246,		2435,		2658,		2926,
//	3252,		3660,		4185,		4884,		5863,		7330,		9776,		14666,		29334,
//	65535
//};


//unsigned short Tabcot[181] = 
//{
//	//0:0.5:90 度； 乘以256；2的8次方，运算时左移8位； TabCot[ ]>>8;
//	65535,		29334,		14666,		9776,		7330,		5863,		4884,		4185,		3660,
//	3252,		2926,		2658,		2435,		2246,		2084,		1944,		1821,		1712,
//	1616,		1529,		1451,		1381,		1317,		1258,		1204,		1154,		1108,
//	1066,		1026,		989,		955,		923,		892,		864,		837,		811,
//	787,		765,		743,		722,		703,		684,		666,		649,		633,
//	618,		603,		588,		574,		561,		548,		536,		524,		513,
//	502,		491,		481,		471,		461,		452,		443,		434,		426,
//	417,		409,		401,		394,		386,		379,		372,		365,		358,
//	352,		345,		339,		333,		327,		321,		316,		310,		305,
//	299,		294,		289,		284,		279,		274,		269,		265,		260,
//	256,		251,		247,		242,		238,		234,		230,		226,		222,
//	218,		214,		211,		207,		203,		200,		196,		192,		189,
//	185,		182,		179,		175,		172,		169,		166,		163,		159,
//	156,		153,		150,		147,		144,		141,		138,		136,		133,
//	130,		127,		124,		122,		119,		116,		113,		111,		108,
//	106,		103,		100,		98,			95,			93,			90,			88,			85,
//	83,			80,			78,			75,			73,			70,			68,			66,			63,
//	61,			59,			56,			54,			52,			49,			47,			45,			42,
//	40,			38,			35,			33,			31,			29,			26,			24,			22,
//	20,			17,			15,			13,			11,			8,			6,			4,			2,
//	0									
//};

unsigned int TabRcos[361] =
{
	//TabRz[i]=1000*[sin(i)/sin(i+1)-1];
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	6, 6, 6, 6, 6, 6, 6, 6,
	7, 7, 7, 7, 7, 7, 7, 7,
	8, 8, 8, 8, 8, 8, 8,
	9, 9, 9, 9, 9,
	10, 10, 10, 10, 10, 10,
	11, 11, 11, 11, 11,
	12, 12, 12, 12,
	13, 13, 13, 13,
	14, 14, 14,
	15, 15, 15, 15,
	16, 16,
	17, 17, 17,
	18, 18,
	19, 19,
	20, 20, 20,
	21,
	22, 22,
	23,
	24, 24,
	25,
	26, 26,
	27, 28, 29, 30, 31, 32, 33, 34, 36, 37, 39, 40, 42, 44, 47, 49, 52, 55, 58, 62, 66, 71, 76, 82, 90,
	99, 110, 124, 143, 166, 200, 249, 333, 500, 1000, 94333, 990, 500, 334, 250, 200, 167, 143, 126,
	111, 100, 91, 83, 77, 72, 67, 63, 59, 56, 53, 50, 48, 45, 44, 42, 40, 38, 37, 35, 34, 33, 32, 31, 30,
	29, 28, 27, 27, 26, 25, 25, 24,
	23, 23, 22, 22, 21, 21, 20, 20, 19, 19,
	18, 18, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15,
	14, 14, 14, 14, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12,
	11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10,
	9, 9, 9, 9, 9, 9, 9,
	8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	6, 6, 6, 6, 6, 6, 6, 6, 6,
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	10921333,
	990
};
unsigned  short TabRsin[361] =
{
	//TabRx[i]=1000*[(cos(i)/cos(i+1)-1)];
	990, 500, 334, 250, 200, 167, 143, 126, 111, 100, 91, 83, 77, 72, 67, 63,
	59, 56, 53, 50, 48, 45, 44, 42, 40, 38, 37, 35, 34, 33, 32, 31,
	30, 29, 28, 27, 27, 26, 25, 25, 24, 23, 23, 22, 22,
	21, 21, 20, 20, 19, 19, 18, 18, 18, 17,
	17, 17, 16, 16, 16, 15, 15, 15,
	14, 14, 14, 14, 13, 13, 13, 13,
	13, 12, 12, 12, 12, 12, 11, 11,
	11, 11, 11, 10, 10, 10, 10, 10,
	10, 9, 9, 9, 9, 9, 9, 9,
	8, 8, 8, 8, 8, 8, 8, 7,
	7, 7, 7, 7, 7, 7, 7, 7,
	6, 6, 6, 6, 6, 6, 6, 6,
	6, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 5, 5, 4, 4, 4, 4,
	4, 4, 4, 4, 4, 4, 4, 3,
	3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 2, 2, 2, 2, 2,
	2, 2, 2, 2, 2, 2, 2, 2,
	1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 2,
	2, 2, 2, 2, 2, 2, 2, 2,
	2, 2, 2, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 4, 4,
	4, 4, 4, 4, 4, 4, 4, 4,
	5, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 6, 6, 6, 6, 6, 6,
	6, 6, 7, 7, 7, 7, 7, 7,
	7, 7, 8, 8, 8, 8, 8, 8,
	8, 9, 9, 9, 9, 9, 10, 10,
	10, 10, 10, 10, 11, 11, 11, 11,
	11, 12, 12, 12, 12, 13, 13, 13,
	13, 14, 14, 14, 15, 15, 15, 15,
	16, 16, 17, 17, 17, 18, 18, 19,
	19, 20, 20, 20, 21, 22, 22, 23,
	24, 24, 25, 26, 26, 27, 28, 29,
	30, 31, 32, 33, 34, 36, 37, 39,
	40, 42, 44, 47, 49, 52, 55, 58,
	62, 66, 71, 76, 82, 90, 99, 110,
	124, 143, 166, 200, 249, 333, 500, 1000,
	992, 0

};


/************************************************************************/
/* 求均值方法                                                           */
/************************************************************************/
int32 Average(const int32 *a,uint16 num)
{
	uint16 i=0;
	int32 aver=0;
	

	//20140217 参数判断
	if (a  ==  NULL || num<1 )
	{
		return 0;
	}

	for(i=0;i<num;i++)
	{
		aver+=a[i];
	}
	aver=aver/num;
	return aver;

}

/************************************************************************/
/* n邻域均值滤波                                                        */
/************************************************************************/
int32 MeanFilterU(uint16 *pData,int n)
{
	uint16 u16Index=0;
	int32 iSum=0;
	for (u16Index=0;u16Index<n;u16Index++)
	{
		iSum+=pData[u16Index];
	}
	if (n>0)
	{
		return iSum/n;
	}
	else
	{
		return 0;
	}
}

/************************************************************************/
/* n邻域均值滤波                                                        */
/************************************************************************/
int32 MeanFilterI(int32 *pData,int n)
{
	uint16 u16Index=0;
	int32 iSum=0;
	for (u16Index=0;u16Index<n;u16Index++)
	{
		iSum+=pData[u16Index];
	}
	if (n>0)
	{
		return iSum/n;
	}
	else
	{
		return 0;
	}
}

/************************************************************************/
/* //标记曲线变化一致性                                                 */
/************************************************************************/
void IndicateTrends(int32 *pdata,int32 *pIndicate,int len)
{
	int32 l_n32tmpI=0;
//	int32 ThreshPt=0;
	int32 l_n32sign[MAX_CUT]={0};
	if (len>MAX_CUT)
	{
		return;
	}

//	ThreshPt=MAX(len/30+1,5);

	//原始数据差分取符号位
	for (l_n32tmpI=1;l_n32tmpI<len;l_n32tmpI++)
	{
		if(pdata[l_n32tmpI]-pdata[l_n32tmpI-1]>0){
			l_n32sign[l_n32tmpI-1]=1;
		}
		else if (pdata[l_n32tmpI]-pdata[l_n32tmpI-1]<0){
			l_n32sign[l_n32tmpI-1]=-1;
		}
		else{
			l_n32sign[l_n32tmpI-1]=-1;
		}
	}

	for (l_n32tmpI=1;l_n32tmpI<len;l_n32tmpI++)
	{
		pIndicate[l_n32tmpI-1]=Average(&l_n32sign[l_n32tmpI-1],5)>0?-1:1;
	}
}



/************************************************************************/
/* //标记峰谷                                                           */
/************************************************************************/
void IndicatePeaks(int32 *pdata,int32 *pIndicate,int len)
{
	int32 l_n32tmpI=0;
	int32 l_n32sign[MAX_CUT]={0};
	if (len>MAX_CUT)
	{
		return;
	}
	//原始数据差分取符号位
	for (l_n32tmpI=1;l_n32tmpI<len;l_n32tmpI++)
	{
		if(pdata[l_n32tmpI]-pdata[l_n32tmpI-1]>0){
			l_n32sign[l_n32tmpI-1]=1;
		}
		else if (pdata[l_n32tmpI]-pdata[l_n32tmpI-1]<0){
			l_n32sign[l_n32tmpI-1]=-1;
		}
		else{
			l_n32sign[l_n32tmpI-1]=-1;
		}
	}

	//符号数组再次差分
	for (l_n32tmpI=1;l_n32tmpI<len;l_n32tmpI++){
		pIndicate[l_n32tmpI]=l_n32sign[l_n32tmpI]-l_n32sign[l_n32tmpI-1];
	}
}

/************************************************************************/
/* 外形检测                                                             */
/************************************************************************/
void ShapeAnalysis(uint16 *pData,ClusterInfo *pCluster)
{
	int i=0;
	

	if(pCluster->Num<2)
	{
		//未判定
		pCluster->Style=4;
		return ;
	}

	for (i=pCluster->Sta;i<pCluster->End+1;i++)
	{
		if (pData[i]/100<pCluster->AvgH/100+1 && pData[i]>pCluster->AvgH/100-1)
		{
			pCluster->FlatCnt++;
		}
	}

	pCluster->FlatR=pCluster->FlatCnt*100/pCluster->Num;

	if ((pCluster->MaxZ/100-pCluster->AvgH/100<2||pCluster->AvgH/100-pCluster->MinZ/100<2)
		 && pCluster->FlatCnt*100/pCluster->Num>70 && pCluster->MaxZ/100-pCluster->MinZ/100<3)
	{
		pCluster->Style=2;//平坦段
	}
	//else if (pCluster->FlatCnt*100/pCluster->Num>95 && 
	//	(pCluster->MaxZ-pCluster->AvgH<100||pCluster->AvgH-pCluster->MinZ<100))
	//{
	//	pCluster->Style=2;//平坦段
	//}
	else
	{
		if (pCluster->MaxZI<pCluster->MinZI)
		{
			pCluster->Style=1;//下降段
		}
		else
		{
			pCluster->Style=3;//上升段
		}
	}
}


/************************************************************************/
/* 外形检测                                                             */
/************************************************************************/
void ShapeAnalysisEx(uint16 *pData,ClusterInfo *pCluster)
{
	int i=0;
	

	if(pCluster->Num<2)
	{
		//未判定
		pCluster->Style=4;
		return ;
	}

	for (i=pCluster->Sta;i<pCluster->End+1;i++)
	{
		if (pData[i]+50<pCluster->AvgH||pData[i]<pCluster->AvgH+50)
		{
			pCluster->FlatCnt++;
		}
	}

	pCluster->FlatR=pCluster->FlatCnt*100/pCluster->Num;

	if ((pCluster->MaxZ-pCluster->AvgH<50||pCluster->AvgH-pCluster->MinZ<50)
		 && pCluster->FlatCnt*100/pCluster->Num>70 && pCluster->MaxZ-pCluster->MinZ<100)
	{
		pCluster->Style=2;//平坦段
	}
	//else if (pCluster->FlatCnt*100/pCluster->Num>95 && 
	//	(pCluster->MaxZ-pCluster->AvgH<100||pCluster->AvgH-pCluster->MinZ<100))
	//{
	//	pCluster->Style=2;//平坦段
	//}
	else
	{
		if (pCluster->MaxZI<pCluster->MinZI)
		{
			pCluster->Style=1;//下降段
		}
		else
		{
			pCluster->Style=3;//上升段
		}
	}
}



//标记趋势
void IndicateTrend(int32 *pdata,int32 *pIndicate,int len)
{
	int32 l_n32tmpI=0;
	//int32 l_n32sign[FRAME_MAXCNT]={0};
	//原始数据差分取符号位
	for (l_n32tmpI=1;l_n32tmpI<len;l_n32tmpI++)
	{
		if(pdata[l_n32tmpI]-pdata[l_n32tmpI-1]>0){
			pIndicate[l_n32tmpI-1]=1;
		}
		else if (pdata[l_n32tmpI]-pdata[l_n32tmpI-1]<0){
			pIndicate[l_n32tmpI-1]=-1;
		}
		else{
			pIndicate[l_n32tmpI-1]=0;
		}
	}

}


/************************************************************************/
/* N邻域最小值                                                          */
/************************************************************************/
uint16 MIN_N_NEAR(uint16 *pSta,uint16 N,uint16 B_F)
{
	uint16 MinItem=0;
	int32 TmpI=0;
	if (pSta==NULL||N<1)
	{
		return 0;
	}

	//取最初值
	MinItem=pSta[0];

	//遍历寻找最小
	for(TmpI=0;TmpI<N;TmpI++)
	{
		if(*pSta<MinItem)
			MinItem=*pSta;
		if (B_F)
		{
			pSta++;
		}
		else
		{
			pSta--;
		}
	}
	return MinItem;
}

/************************************************************************/
/* 计算车辆高度方法                                                     */
/************************************************************************/
void CalcVehHeight(uint16 *pH,uint16 u16FrameCnt,uint16 *CalHt,uint16 *MaxIndex)
{
	uint16    l_u16ReturnHeight = 0;
	uint16    l_u16Index         = 0;
	uint16    l_u16MaxHeight       = 0;
	uint16    l_u16SecHeight       = 0;
	uint16    l_u16ThdHeight       = 0;
	uint16    l_u16MaxHtIndex=0;
	uint16    l_u16SecHtIndex=0;
	uint16    l_u16ThdHtIndex=0;

	if ( pH  ==  NULL || u16FrameCnt > FRAME_MAXCNT)
		return ;

	//首先检查是否有异常高度,最多检查2个异常点
	for (l_u16Index = 0; l_u16Index < u16FrameCnt; l_u16Index++)
	{
		if (l_u16MaxHeight < pH[l_u16Index])
		{
			l_u16ThdHeight = l_u16SecHeight;
			l_u16ThdHtIndex=l_u16SecHtIndex;
			l_u16SecHeight = l_u16MaxHeight;
			l_u16SecHtIndex=l_u16MaxHtIndex;
			l_u16MaxHeight = pH[l_u16Index];
			l_u16MaxHtIndex=l_u16Index;
		}
		else if (l_u16SecHeight < pH[l_u16Index])
		{
			l_u16ThdHeight = l_u16SecHeight;
			l_u16ThdHtIndex=l_u16SecHtIndex;
			l_u16SecHeight =  pH[l_u16Index];
			l_u16SecHtIndex=l_u16Index;
		}
		else if (l_u16ThdHeight <  pH[l_u16Index]) //20140709增加
		{
			l_u16ThdHeight =  pH[l_u16Index];
			l_u16ThdHtIndex=l_u16Index;
		}
	}

	if (l_u16ThdHeight  &&  l_u16SecHeight > l_u16ThdHeight + 300  &&  l_u16SecHeight) //2个点异常
	{
		l_u16ReturnHeight = l_u16ThdHeight;
		*CalHt=l_u16ReturnHeight;
		*MaxIndex=l_u16ThdHtIndex;
	}
	else if (l_u16SecHeight  &&  l_u16MaxHeight > l_u16SecHeight + 300  &&  l_u16MaxHeight) //1个点异常
	{
		l_u16ReturnHeight = l_u16SecHeight;
		*CalHt=l_u16ReturnHeight;
		*MaxIndex=l_u16SecHtIndex;
	}
	else 
	{
		l_u16ReturnHeight = l_u16MaxHeight;
		*CalHt=l_u16ReturnHeight;
		*MaxIndex=l_u16MaxHtIndex;
	}
}
